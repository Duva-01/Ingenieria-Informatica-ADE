/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"

calc_res *
sumar_1_svc(Operacion operacion,  struct svc_req *rqstp)
{
	static calc_res  result;
    xdr_free(xdr_calc_res, &result);

    result.calc_res_u.resultado = operacion.a + operacion.b;

    printf("SERVIDOR: \n");
    printf("El resultado de la operacion %d %c %d ==> %lf \n", operacion.a, operacion.operador, operacion.b, result.calc_res_u.resultado);
    
    return &result;
}

calc_res *
restar_1_svc(Operacion operacion,  struct svc_req *rqstp)
{
	static calc_res  result;

    xdr_free(xdr_calc_res, &result);

    result.calc_res_u.resultado = operacion.a - operacion.b;

    printf("SERVIDOR: \n");
    printf("El resultado de la operacion %d %c %d ==> %lf \n", operacion.a, operacion.operador, operacion.b, result.calc_res_u.resultado);
    return &result;
}

calc_res *
multiplicar_1_svc(Operacion operacion,  struct svc_req *rqstp)
{
	static calc_res  result;

    xdr_free(xdr_calc_res, &result);

    result.calc_res_u.resultado = operacion.a * operacion.b;
	operacion.

    printf("SERVIDOR: \n");
    printf("El resultado de la operacion %d %c %d ==> %lf \n", operacion.a, operacion.operador, operacion.b, result.calc_res_u.resultado);
    
    return &result;
}

calc_res *
dividir_1_svc(Operacion operacion,  struct svc_req *rqstp)
{
	static calc_res  result;

    xdr_free(xdr_calc_res, &result);

    if(operacion.b == 0){
		
        printf("No se puede dividir entre 0 \n");
		result.calc_res_u.resultado = 0;

        return &result;
    }
    
    result.calc_res_u.resultado = operacion.a / operacion.b;

    printf("SERVIDOR: \n");
    printf("El resultado de la operacion %d %c %d ==> %lf \n", operacion.a, operacion.operador, operacion.b, result.calc_res_u.resultado);

    return &result;
}

calc_res_vec *
op_compleja_server_1_svc(vOper polinomio,  struct svc_req *rqstp)
{
	static calc_res_vec result;
	printf("\n --- Operaciones Complejas --- \n");

	printf("El tamanio de las operaciones es: %i \n", polinomio.vOper_len);
	
	result.calc_res_vec_u.resultado.resVec_val =  malloc(polinomio.vOper_len* sizeof(double));
	result.calc_res_vec_u.resultado.resVec_len = polinomio.vOper_len;

	

	for(int i=0; i<polinomio.vOper_len; i++){

		switch (polinomio.vOper_val[i].operador)
    {
		case '+':

			result.calc_res_vec_u.resultado.resVec_val[i] = polinomio.vOper_val[i].a + polinomio.vOper_val[i].b;

			printf("Operacion del Cliente %i: %d %c %d ==> %lf \n", i, polinomio.vOper_val[i].a, polinomio.vOper_val[i].operador, polinomio.vOper_val[i].b, result.calc_res_vec_u.resultado.resVec_val[i]);
			break;

		case '-':

			result.calc_res_vec_u.resultado.resVec_val[i] = polinomio.vOper_val[i].a - polinomio.vOper_val[i].b;
			printf("Operacion del Cliente %i: %d %c %d ==> %lf \n", i, polinomio.vOper_val[i].a, polinomio.vOper_val[i].operador, polinomio.vOper_val[i].b, result.calc_res_vec_u.resultado.resVec_val[i]);

			break;

		case 'x':

			result.calc_res_vec_u.resultado.resVec_val[i] = polinomio.vOper_val[i].a * polinomio.vOper_val[i].b;
			printf("Operacion del Cliente %i: %d %c %d ==> %lf \n", i, polinomio.vOper_val[i].a, polinomio.vOper_val[i].operador, polinomio.vOper_val[i].b, result.calc_res_vec_u.resultado.resVec_val[i]);
			break;

		case '/':
			
			if(polinomio.vOper_val[i].b == 0){
				
				printf("No se puede dividir entre 0 \n");
				result.calc_res_vec_u.resultado.resVec_val[i] = 0;
			}
			else {
				result.calc_res_vec_u.resultado.resVec_val[i] = polinomio.vOper_val[i].a / polinomio.vOper_val[i].b;
				printf("Operacion del Cliente %i: %d %c %d ==> %lf \n", i, polinomio.vOper_val[i].a, polinomio.vOper_val[i].operador, polinomio.vOper_val[i].b, result.calc_res_vec_u.resultado.resVec_val[i]);
			} 
			break;
		
		default:
			break;
    	}
	}
	
	return &result;
}

calc_res_vec *
op_vectores_server_1_svc(resVec vector1, resVec vector2, int opcion,  struct svc_req *rqstp)
{
    static calc_res_vec  result;

	double * vec1 = vector1.resVec_val;
	double * vec2 = vector2.resVec_val;
	int size = vector1.resVec_len;

	result.calc_res_vec_u.resultado.resVec_val = malloc(size * sizeof(double));
	result.calc_res_vec_u.resultado.resVec_len = size;

	switch (opcion)
	{
		case 1:

			for (int i = 0 ; i < size ; i++){
				result.calc_res_vec_u.resultado.resVec_val[i] = vec1[i] + vec2[i];
			}
			break;
		
		case 2:

			for (int i = 0 ; i < size ; i++){
				result.calc_res_vec_u.resultado.resVec_val[i] = vec1[i] - vec2[i];
			}
			break;

		case 3:

			result.calc_res_vec_u.resultado.resVec_val[0] = 0;

			for (int i = 0 ; i < size ; i++){
				result.calc_res_vec_u.resultado.resVec_val[0] += (vec1[i] * vec2[i]);
			}
			break;

		case 4:

			result.calc_res_vec_u.resultado.resVec_val[0] = (vec1[1] * vec2[2]) - (vec1[2] * vec2[1]);	
			result.calc_res_vec_u.resultado.resVec_val[1] = (vec1[0] * vec2[2]) - (vec1[2] * vec2[0]);
			result.calc_res_vec_u.resultado.resVec_val[2] = (vec1[0] * vec2[1]) - (vec1[1] * vec2[0]);
			
			break;

		default:
			break;
	}


    return &result;
}